<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"/>
<title>PB&J Coach — Mobile Tough Grader</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
:root{
  --bg:#0b0c10; --panel:#12141a; --muted:#96a0b8; --text:#e6e8ee; --accent:#60a5fa;
  --good:#34d399; --warn:#fbbf24; --bad:#ef4444; --panel2:#0f1220; --line:#28304a;
}
*{box-sizing:border-box} html,body{height:100%}
body{margin:0;background:#0b0c10;color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,sans-serif}
header{padding:12px 16px;font-weight:800;letter-spacing:.2px;position:sticky;top:0;background:#0b0c10;z-index:10}
.wrap{max-width:1200px;margin:0 auto;padding:10px;display:grid;gap:10px}
.grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
@media (max-width:900px){ .grid{grid-template-columns:1fr} }
.card{background:var(--panel);border:1px solid #1d2130;border-radius:16px;padding:10px;box-shadow:0 10px 24px rgba(0,0,0,.2)}
.controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}
button{background:#0f1425;color:var(--text);border:1px solid #2b3453;padding:12px 14px;border-radius:12px;cursor:pointer;font-weight:700;touch-action:manipulation}
button:active{transform:scale(.98)}
.btn-primary{background:#0f2245;border-color:#3b5bcc}
.small{font-size:12px;color:var(--muted)}
.videoWrap{position:relative;border-radius:12px;overflow:hidden}
video,canvas{display:block;width:100%;height:auto;touch-action:none}
.hud{position:absolute;left:8px;bottom:8px;right:8px;display:flex;gap:8px;flex-wrap:wrap;background:rgba(5,8,14,.55);
  backdrop-filter:blur(6px);border:1px solid #2a2e40;padding:6px 8px;border-radius:12px;font-size:13px}
.pill{padding:4px 8px;border-radius:999px;background:#0f1220;border:1px solid #28304a}
.status{font-weight:900}
.status.go{color:var(--good)} .status.pause{color:var(--warn)} .status.stop{color:var(--bad)}
.overlayPrompt{position:absolute;top:10px;left:10px;right:10px;display:flex;justify-content:center}
.prompt{background:#111827d9;border:1px solid #1f2937;color:#e5e7eb;padding:10px 12px;border-radius:12px;font-weight:700;max-width:90%;text-align:center}
.badge{font-size:11px;color:#cbd5e1;background:#0f1220;border:1px solid #28304a;border-radius:999px;padding:2px 8px}
.flex{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.step{padding:8px 10px;border:1px solid var(--line);border-radius:10px}
.step.active{border-color:var(--accent);box-shadow:0 0 0 2px rgba(96,165,250,.25) inset}
.kv{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.kv > div{background:var(--panel2);border:1px solid var(--line);border-radius:12px;padding:10px}
.kv h4{margin:0 0 6px 0;font-size:12px;color:#b8c1d9;letter-spacing:.2px}
.val{font-weight:800}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
@media (max-width:700px){ .grid2{grid-template-columns:1fr} }
.meter{height:10px;background:#101425;border:1px solid #28304a;border-radius:999px;overflow:hidden}
.meter>span{display:block;height:100%;background:var(--accent);width:0%}
.score{font-size:32px;font-weight:900}
/* Sim bread panel */
.breadPanel{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.slice{background:#161926;border:1px solid #28304a;border-radius:12px;padding:8px}
.slice canvas{width:100%;height:auto;background:#f4e2c3;border-radius:10px;border:1px solid #c8ad7a}
.slice h5{margin:6px 0 6px 0;font-size:12px;color:#cbd5e1}
.notice{padding:8px 10px;border-radius:10px;background:#111827;border:1px solid #1f2937;color:#d1d5db}
label.touch{display:inline-block;padding:8px 10px;border:1px solid #2b3453;border-radius:12px}
.toggle{display:flex;gap:8px;align-items:center}
.switch{appearance:none;width:44px;height:26px;border-radius:999px;background:#26324f;position:relative;outline:none;border:1px solid #3b4a77}
.switch:checked{background:#1e3a8a}
.switch::after{content:"";position:absolute;top:3px;left:3px;width:20px;height:20px;border-radius:999px;background:#e5e7eb;transition:left .15s}
.switch:checked::after{left:21px}
</style>
</head>
<body>
<header>PB&J Coach — Mobile Tough Grader</header>
<div class="wrap">
  <div class="grid">
    <div class="card">
      <div class="controls">
        <button id="startBtn" class="btn-primary">Start Session</button>
        <button id="nextBtn">Next Step</button>
        <button id="pauseBtn">Pause</button>
        <button id="resetBtn">Reset</button>
        <label class="toggle"><input id="rearCam" type="checkbox" class="switch"/><span class="small">Use rear camera (phone)</span></label>
      </div>

      <div class="videoWrap">
        <video id="video" playsinline muted></video>
        <canvas id="overlay"></canvas>
        <div class="overlayPrompt"><div id="prompt" class="prompt" style="display:none"></div></div>
        <div class="hud">
          <div class="pill">State: <span id="state" class="status stop">Idle</span></div>
          <div class="pill">Step: <span id="stepName">—</span></div>
          <div class="pill">Timer: <span id="timer">0:00</span></div>
          <div class="pill">Hands: <span id="hands">0</span></div>
          <div class="pill">PB%: <span id="pbPct">0</span></div>
          <div class="pill">J%: <span id="jPct">0</span></div>
          <div class="pill">Mess: <span id="messPct">0</span></div>
        </div>
      </div>

      <div class="flex" style="margin-top:8px">
        <div class="step" id="step0"><b>0.</b> Calibrate & Setup</div>
        <div class="step" id="step1"><b>1.</b> Lay bread</div>
        <div class="step" id="step2"><b>2.</b> Peanut butter spread</div>
        <div class="step" id="step3"><b>3.</b> Jelly spread</div>
        <div class="step" id="step4"><b>4.</b> Assemble</div>
        <div class="step" id="step5"><b>5.</b> Rotate & Grade</div>
        <div class="step" id="step6"><b>6.</b> Cleanup</div>
      </div>

      <div class="grid2" style="margin-top:8px">
        <div class="kv">
          <div><h4>Total time</h4><div class="val" id="totTime">0:00</div></div>
          <div><h4>Idle %</h4><div class="val" id="idlePct">0%</div></div>
          <div><h4>PB coverage (both)</h4><div class="val" id="pbCover">0%</div></div>
          <div><h4>Jelly coverage (both)</h4><div class="val" id="jCover">0%</div></div>
        </div>
        <div class="breadPanel">
          <div class="slice">
            <h5>Slice A (tap 2 corners to calibrate)</h5>
            <canvas id="sliceA" width="240" height="240"></canvas>
          </div>
          <div class="slice">
            <h5>Slice B (tap 2 corners to calibrate)</h5>
            <canvas id="sliceB" width="240" height="240"></canvas>
          </div>
        </div>
      </div>

      <div class="notice" style="margin-top:8px">
        <b>How it works:</b> Tap two opposite corners of each slice in the live video to calibrate ROIs during step 0. 
        The app detects PB (brown/tan) and Jelly (red/purple) inside the slice ROIs and paints simulated coverage on the slice canvases. 
        It also tracks mess (PB/J pixels detected outside the slices and on hands). Prompts will appear here to guide you between steps.
      </div>
    </div>

    <div class="card">
      <h3 style="margin:6px 0 8px 0">Scores</h3>
      <div class="score" id="overallScore">—</div>
      <div class="meter" style="margin:6px 0 12px 0"><span id="overallBar"></span></div>
      <div class="kv">
        <div><h4>Speed</h4><div class="val" id="scoreSpeed">—</div></div>
        <div><h4>Coverage PB</h4><div class="val" id="scorePB">—</div></div>
        <div><h4>Coverage Jelly</h4><div class="val" id="scoreJ">—</div></div>
        <div><h4>Evenness</h4><div class="val" id="scoreEven">—</div></div>
        <div><h4>Cleanliness / Mess</h4><div class="val" id="scoreMess">—</div></div>
        <div><h4>Assembly & Presentation</h4><div class="val" id="scoreAsm">—</div></div>
      </div>
      <h3 style="margin:12px 0 6px 0">Charts</h3>
      <canvas id="barTimes" height="180"></canvas>
      <canvas id="radar" height="220" style="margin-top:10px"></canvas>
    </div>
  </div>
</div>

<script>
(async function(){
  // --- Elements
  const video = document.getElementById('video');
  const canvas = document.getElementById('overlay');
  const ctx = canvas.getContext('2d', { willReadFrequently:true });
  const startBtn = document.getElementById('startBtn');
  const nextBtn = document.getElementById('nextBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const rearCam = document.getElementById('rearCam');
  const stateEl = document.getElementById('state');
  const stepNameEl = document.getElementById('stepName');
  const timerEl = document.getElementById('timer');
  const totTimeEl = document.getElementById('totTime');
  const handsEl = document.getElementById('hands');
  const pbPctEl = document.getElementById('pbPct');
  const jPctEl = document.getElementById('jPct');
  const messPctEl = document.getElementById('messPct');
  const promptBox = document.getElementById('prompt');

  const sliceA = document.getElementById('sliceA');
  const sliceB = document.getElementById('sliceB');
  const sA = sliceA.getContext('2d');
  const sB = sliceB.getContext('2d');

  const overallScoreEl = document.getElementById('overallScore');
  const overallBar = document.getElementById('overallBar');
  const scoreSpeedEl = document.getElementById('scoreSpeed');
  const scorePBEl = document.getElementById('scorePB');
  const scoreJEl = document.getElementById('scoreJ');
  const scoreEvenEl = document.getElementById('scoreEven');
  const scoreMessEl = document.getElementById('scoreMess');
  const scoreAsmEl = document.getElementById('scoreAsm');

  const pbCoverEl = document.getElementById('pbCover');
  const jCoverEl = document.getElementById('jCover');
  const idlePctEl = document.getElementById('idlePct');

  // --- Steps
  const steps = [
    {name:'Calibrate & Setup', prompt:'Tap two opposite corners of Slice A, then Slice B. Make sure bread fills the frame. When done, tap Next.'},
    {name:'Lay bread', prompt:'Lay both slices flat and centered in frame.'},
    {name:'Peanut butter spread', prompt:'Spread PB on Slice A. Aim to cover edges evenly.'},
    {name:'Jelly spread', prompt:'Spread Jelly on Slice B. Aim to cover edges evenly.'},
    {name:'Assemble', prompt:'Place slices together carefully. Keep PB/J inside edges.'},
    {name:'Rotate & Grade', prompt:'Hold the finished sandwich and slowly rotate it 360° in front of the camera for 5–8 seconds.'},
    {name:'Cleanup', prompt:'Close jars, wipe surface, wash hands. Keep it tidy.'}
  ];
  let curStep = -1, stepStart = 0;
  const stepTimes = new Array(steps.length).fill(0);

  // --- Timing
  let running = false, paused = false, startTime = 0, totalElapsed = 0;
  let lastHandsTs = 0, idleMs = 0;

  // --- MediaPipe Hands
  const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
  hands.setOptions({ maxNumHands:2, modelComplexity:1, minDetectionConfidence:0.6, minTrackingConfidence:0.6 });

  let stream;
  async function startCam(){
    // Prefer rear camera on phones if toggled
    const facingMode = rearCam.checked ? { exact: "environment" } : "user";
    stream = await navigator.mediaDevices.getUserMedia({
      video:{ facingMode, width:{ideal:1280}, height:{ideal:720} }, audio:false
    });
    video.srcObject = stream;
    await video.play();
    video.requestVideoFrameCallback(tick);
  }

  // --- ROI calibration for slices (user taps two corners in the live video)
  const roi = { A:null, B:null }; // {x1,y1,x2,y2} in video pixel coords
  let awaitingClicks = 0; // 0=idle, 1=first A, 2=second A, 3=first B, 4=second B
  function showPrompt(txt){ promptBox.style.display='block'; promptBox.textContent=txt; }
  function hidePrompt(){ promptBox.style.display='none'; }

  function beginCalibration(){
    awaitingClicks = 1;
    showPrompt('Tap top-left corner of Slice A.');
  }

  canvas.addEventListener('pointerdown', (e)=>{
    if (curStep !== 0) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width/rect.width);
    const y = (e.clientY - rect.top) * (canvas.height/rect.height);
    if (awaitingClicks===1){ roi.A = {x1:x, y1:y, x2:x, y2:y}; awaitingClicks=2; showPrompt('Tap bottom-right corner of Slice A.'); }
    else if (awaitingClicks===2){ roi.A.x2=x; roi.A.y2=y; awaitingClicks=3; showPrompt('Tap top-left corner of Slice B.'); }
    else if (awaitingClicks===3){ roi.B = {x1:x, y1:y, x2:x, y2:y}; awaitingClicks=4; showPrompt('Tap bottom-right corner of Slice B.'); }
    else if (awaitingClicks===4){ roi.B.x2=x; roi.B.y2=y; awaitingClicks=0; showPrompt('Calibration saved. Proceed when ready.'); setTimeout(hidePrompt,1500); }
  });

  function drawRoi(){
    ctx.save();
    ctx.strokeStyle = '#60a5fa'; ctx.lineWidth = 2;
    if (roi.A){ ctx.strokeRect(Math.min(roi.A.x1,roi.A.x2), Math.min(roi.A.y1,roi.A.y2),
                               Math.abs(roi.A.x2-roi.A.x1), Math.abs(roi.A.y2-roi.A.y1)); }
    if (roi.B){ ctx.strokeStyle = '#34d399';
      ctx.strokeRect(Math.min(roi.B.x1,roi.B.x2), Math.min(roi.B.y1,roi.B.y2),
                     Math.abs(roi.B.x2-roi.B.x1), Math.abs(roi.B.y2-roi.B.y1)); }
    ctx.restore();
  }

  // --- Color detection (very heuristic, works best with good lighting)
  function rgb2hsv(r,g,b){
    r/=255; g/=255; b/=255;
    const max = Math.max(r,g,b), min = Math.min(r,g,b); const d = max-min;
    let h=0, s= (max===0?0:d/max), v=max;
    if (d!==0){
      switch(max){
        case r: h = (g-b)/d + (g<b?6:0); break;
        case g: h = (b-r)/d + 2; break;
        case b: h = (r-g)/d + 4; break;
      }
      h/=6;
    }
    return {h:h*360, s, v};
  }

  // Tunable color ranges
  const PB = { h:[15, 55], s:[0.25, 0.75], v:[0.35, 0.95] };     // tan/brown
  const J  = { h:[300, 360], s:[0.35, 1.0], v:[0.25, 1.0], wrap:true }; // purple/red
  const J2 = { h:[0, 20],    s:[0.35, 1.0], v:[0.25, 1.0] };      // red range (wrap)

  function inRange(hsv, R){
    const inS = hsv.s>=R.s[0] && hsv.s<=R.s[1];
    const inV = hsv.v>=R.v[0] && hsv.v<=R.v[1];
    if (R.wrap){ return inS && inV && (hsv.h>=R.h[0] || hsv.h<=R.h[1]); }
    return inS && inV && hsv.h>=R.h[0] && hsv.h<=R.h[1];
  }

  // Coverage buffers for simulated bread (240x240)
  const covA = sA.createImageData(240,240);
  const covB = sB.createImageData(240,240);
  function clearCoverage(img){ for(let i=0;i<img.data.length;i++) img.data[i]=0; }

  clearCoverage(covA); clearCoverage(covB);

  let pbCountA=0, pbCountB=0, jCountA=0, jCountB=0, areaA=240*240, areaB=240*240;
  let messCount=0, messArea=1;

  function paintSlice(ctx2d, covImg){
    // covImg stores per-pixel alpha with PB/J channels encoded: R=PB, B=J
    const w = covImg.width, h = covImg.height;
    const out = ctx2d.createImageData(w,h);
    for (let i=0;i<w*h;i++){
      const r = covImg.data[i*4+0];
      const g = covImg.data[i*4+1];
      const b = covImg.data[i*4+2];
      const a = covImg.data[i*4+3];
      // base bread color
      out.data[i*4+0] = 244; // bread base
      out.data[i*4+1] = 226;
      out.data[i*4+2] = 195;
      out.data[i*4+3] = 255;
      // overlay PB (tan) and J (purple) additively
      if (r>0){
        out.data[i*4+0] = Math.max(170, out.data[i*4+0]-40);
        out.data[i*4+1] = Math.max(120, out.data[i*4+1]-70);
      }
      if (b>0){
        out.data[i*4+0] = Math.max(120, out.data[i*4+0]-80);
        out.data[i*4+2] = Math.max(120, out.data[i*4+2]-30);
      }
    }
    ctx2d.putImageData(out,0,0);
    // edge stroke
    ctx2d.strokeStyle = '#c8ad7a'; ctx2d.lineWidth = 2; ctx2d.strokeRect(1,1,w-2,h-2);
  }

  // Map a pixel in video ROI to 240x240 slice map
  function fillCoverageFromROI(frame, roiRect, covImg, isPB, isJ){
    const x1 = Math.min(roiRect.x1, roiRect.x2), y1 = Math.min(roiRect.y1, roiRect.y2);
    const x2 = Math.max(roiRect.x1, roiRect.x2), y2 = Math.max(roiRect.y1, roiRect.y2);
    const w = x2-x1, h = y2-y1;
    const stepX = Math.max(1, Math.floor(w/240));
    const stepY = Math.max(1, Math.floor(h/240));
    for (let vy=y1, sy=0; vy<y2 && sy<240; vy+=stepY, sy++){
      for (let vx=x1, sx=0; vx<x2 && sx<240; vx+=stepX, sx++){
        const idx = ((vy|0)*frame.width + (vx|0))*4;
        const r = frame.data[idx], g=frame.data[idx+1], b=frame.data[idx+2];
        const hsv = rgb2hsv(r,g,b);
        const pb = inRange(hsv, PB);
        const j  = inRange(hsv, J) || inRange(hsv, J2);
        const oi = (sy*240 + sx)*4;
        if (pb && isPB){ covImg.data[oi+0] = 255; covImg.data[oi+3]=225; } // PB -> red channel
        if (j && isJ){  covImg.data[oi+2] = 255; covImg.data[oi+3]=225; } // Jelly -> blue channel
      }
    }
  }

  function coverageStats(img){
    const w=img.width,h=img.height; let pb=0,j=0;
    for (let i=0;i<w*h;i++){
      if (img.data[i*4+0]>0) pb++;
      if (img.data[i*4+2]>0) j++;
    }
    return { pb: pb/(w*h), j: j/(w*h) };
  }

  function messStats(frame){
    // Any PB/J colored pixel OUTSIDE slice ROIs counts as mess.
    let m=0, tot=frame.width*frame.height;
    const x1A=roi.A?Math.min(roi.A.x1,roi.A.x2):-1, y1A=roi.A?Math.min(roi.A.y1,roi.A.y2):-1,
          x2A=roi.A?Math.max(roi.A.x1,roi.A.x2):-1, y2A=roi.A?Math.max(roi.A.y1,roi.A.y2):-1;
    const x1B=roi.B?Math.min(roi.B.x1,roi.B.x2):-1, y1B=roi.B?Math.min(roi.B.y1,roi.B.y2):-1,
          x2B=roi.B?Math.max(roi.B.x1,roi.B.x2):-1, y2B=roi.B?Math.max(roi.B.y1,roi.B.y2):-1;
    for (let y=0;y<frame.height;y+=2){
      for (let x=0;x<frame.width;x+=2){
        const inA = roi.A && x>=x1A && x<=x2A && y>=y1A && y<=y2A;
        const inB = roi.B && x>=x1B && x<=x2B && y>=y1B && y<=y2B;
        if (inA || inB) continue;
        const idx = (y*frame.width + x)*4;
        const hsv = rgb2hsv(frame.data[idx], frame.data[idx+1], frame.data[idx+2]);
        const isMess = inRange(hsv, PB) || inRange(hsv, J) || inRange(hsv, J2);
        if (isMess) m++;
      }
    }
    return m / (tot/4);
  }

  // --- Scores
  let scoreSpeed=0, scorePB=0, scoreJ=0, scoreEven=0, scoreMess=0, scoreAsm=0, overall=0;
  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
  function updateScores(totalMs, covAStats, covBStats, messRatio){
    // Speed (<=3:00 best; >5:00 harsh)
    const s = totalMs/1000;
    scoreSpeed = s<=180? 100 : s<=240? 85 : s<=300? 70 : clamp(70-(s-300)/5, 30, 70);

    // Coverage
    const pbC = (covAStats.pb + covBStats.pb)/2;
    const jC  = (covAStats.j  + covBStats.j )/2;
    scorePB = clamp( pbC*120, 0, 100);  // 83%+ → 100
    scoreJ  = clamp( jC*120,  0, 100);

    // Evenness = how uniform coverage is (count transitions in 10x10 grid)
    function evenScore(img){
      const w=img.width,h=img.height, gs=10;
      let transitions=0, cells=0;
      for (let y=0;y<h;y+=gs){
        for (let x=0;x<w;x+=gs){
          let has=0;
          for (let yy=y; yy<y+gs && yy<h; yy+=2){
            for (let xx=x; xx<x+gs && xx<w; xx+=2){
              const i=(yy*w+xx)*4;
              if (img.data[i]>0 || img.data[i+2]>0){ has=1; break; }
            }
            if (has) break;
          }
          // Count boundary: neighbors differ
          let neigh=0;
          if (x+gs<w){ // right
            let hasR=0;
            for (let yy=y; yy<y+gs && yy<h; yy+=2){
              for (let xx=x+gs; xx<x+gs+gs && xx<w; xx+=2){
                const j=(yy*w+xx)*4;
                if (img.data[j]>0 || img.data[j+2]>0){ hasR=1; break; }
              }
              if (hasR) break;
            }
            if (has !== hasR) neigh++;
          }
          if (y+gs<h){ // bottom
            let hasB=0;
            for (let yy=y+gs; yy<y+gs+gs && yy<h; yy+=2){
              for (let xx=x; xx<x+gs && xx<w; xx+=2){
                const j=(yy*w+xx)*4;
                if (img.data[j]>0 || img.data[j+2]>0){ hasB=1; break; }
              }
              if (hasB) break;
            }
            if (has !== hasB) neigh++;
          }
          transitions += neigh;
          cells++;
        }
      }
      const maxT = cells*2;
      const uniformity = 1 - (transitions/maxT); // 1=very uniform
      return clamp(uniformity*100, 0, 100);
    }
    scoreEven = Math.round((evenScore(covA) + evenScore(covB)) / 2);

    // Mess (outside ROIs). 0 mess = 100, heavy mess down to 30
    scoreMess = clamp(100 - (messRatio*250), 30, 100);

    // Assembly & presentation (placeholder until assemble & rotate phase refines)
    // Start from clean base; later refined during Step 5 by edge spill detection.
    scoreAsm = 80;

    // Overall weighted
    overall = Math.round(
      0.25*scoreSpeed + 0.20*scorePB + 0.20*scoreJ +
      0.15*scoreEven + 0.10*scoreMess + 0.10*scoreAsm
    );

    // UI
    overallScoreEl.textContent = overall;
    overallBar.style.width = overall + '%';
    scoreSpeedEl.textContent = Math.round(scoreSpeed);
    scorePBEl.textContent = Math.round(scorePB);
    scoreJEl.textContent = Math.round(scoreJ);
    scoreEvenEl.textContent = Math.round(scoreEven);
    scoreMessEl.textContent = Math.round(scoreMess);
    scoreAsmEl.textContent = Math.round(scoreAsm);
  }

  // --- Charts
  const barTimes = new Chart(document.getElementById('barTimes').getContext('2d'), {
    type:'bar',
    data:{ labels:steps.map(s=>s.name), datasets:[{ label:'Time (s)', data:stepTimes.map(ms=>ms/1000) }] },
    options:{ animation:false, plugins:{legend:{display:false}}, scales:{y:{beginAtZero:true}} }
  });
  const radar = new Chart(document.getElementById('radar').getContext('2d'), {
    type:'radar',
    data:{ labels:['Speed','PB','Jelly','Evenness','Mess','Assembly'],
      datasets:[{ label:'Scores', data:[0,0,0,0,0,0] }] },
    options:{ animation:false, plugins:{legend:{display:false}}, scales:{ r:{min:0, max:100} } }
  });

  function updateCharts(){
    barTimes.data.datasets[0].data = stepTimes.map(ms=>Math.round(ms/1000));
    barTimes.update('none');
    radar.data.datasets[0].data = [scoreSpeed,scorePB,scoreJ,scoreEven,scoreMess,scoreAsm];
    radar.update('none');
  }

  function setState(txt, cls){ stateEl.textContent=txt; stateEl.className='status '+cls; }
  function startStep(i, now){ curStep=i; stepStart=now; stepNameEl.textContent=steps[i].name; showPrompt(steps[i].prompt); setState('Running','go');
    if (i===0) beginCalibration(); }
  function endStep(i, now){ stepTimes[i] += now-stepStart; updateCharts(); hidePrompt(); }

  // --- Main processing loop (rVFC so it works in background better)
  hands.onResults(onHandsResults);

  function onHandsResults(res){
    // Draw camera
    canvas.width = res.image.width;
    canvas.height = res.image.height;
    ctx.drawImage(res.image,0,0,canvas.width,canvas.height);

    // Draw landmarks
    const lms = res.multiHandLandmarks;
    let handsCount = (lms && lms.length) ? lms.length : 0;
    handsEl.textContent = String(handsCount);
    if (lms){ for (const h of lms){ drawConnectors(ctx,h,HAND_CONNECTIONS,{lineWidth:2}); } }

    // Idle
    const now = performance.now();
    if (handsCount>0) lastHandsTs = now;
    if (running && !paused){ if (now - lastHandsTs > 800) idleMs += 16; }

    // PB/J detection + coverage update
    try{
      const frame = ctx.getImageData(0,0,canvas.width,canvas.height);
      messArea = canvas.width*canvas.height;
      // Fill coverage only during PB/J steps
      if (roi.A && (curStep===2 || curStep===3)){
        fillCoverageFromROI(frame, roi.A, covA, curStep===2, curStep===3);
        fillCoverageFromROI(frame, roi.B, covB, curStep===2, curStep===3);
      }
      // Paint simulated bread
      paintSlice(sA, covA);
      paintSlice(sB, covB);

      // Stats
      const statsA = coverageStats(covA);
      const statsB = coverageStats(covB);
      const pbCover = Math.round((statsA.pb+statsB.pb)/2*100);
      const jCover  = Math.round((statsA.j +statsB.j )/2*100);
      pbPctEl.textContent = pbCover + '%';
      jPctEl.textContent  = jCover + '%';
      pbCoverEl.textContent = pbCover + '%';
      jCoverEl.textContent  = jCover + '%';

      // Mess
      const mess = messStats(frame);
      messPctEl.textContent = Math.round(mess*100)+'%';

      // Update scores continuously
      const tnow = performance.now();
      let totalMs = totalElapsed;
      if (running && !paused) totalMs += tnow - startTime;
      updateScores(totalMs, statsA, statsB, mess);
      idlePctEl.textContent = Math.round((totalMs?idleMs/totalMs:0)*100)+'%';
      updateCharts();

      // Assembly step refinements: penalize spills near ROI borders
      if (curStep===5){
        // Look for PB/J near edges (within 5% outside of ROI bounds) → reduce assembly
        function edgeSpill(frame, r){
          const padX = Math.round(Math.abs(r.x2-r.x1)*0.06);
          const padY = Math.round(Math.abs(r.y2-r.y1)*0.06);
          const x1=Math.max(0,Math.min(r.x1,r.x2)-padX), y1=Math.max(0,Math.min(r.y1,r.y2)-padY);
          const x2=Math.min(frame.width, Math.max(r.x1,r.x2)+padX), y2=Math.min(frame.height, Math.max(r.y1,r.y2)+padY);
          let spill=0, tot=1;
          for (let y=y1; y<y2; y+=2){
            for (let x=x1; x<x2; x+=2){
              const border = (x<x1+padX || x>x2-padX || y<y1+padY || y>y2-padY);
              if (!border) continue;
              const idx=(y*frame.width+x)*4;
              const hsv=rgb2hsv(frame.data[idx], frame.data[idx+1], frame.data[idx+2]);
              const is= inRange(hsv,PB) || inRange(hsv,J) || inRange(hsv,J2);
              if (is) spill++;
              tot++;
            }
          }
          return spill/(tot);
        }
        const spillA = roi.A? edgeSpill(frame, roi.A):0;
        const spillB = roi.B? edgeSpill(frame, roi.B):0;
        const spill = (spillA+spillB)/2;
        scoreAsm = clamp(95 - spill*500, 30, 95);
      }

    } catch(e){ /* ignore readback errors */ }

    // Draw ROI boxes
    drawRoi();
  }

  async function tick(now, meta){
    if (running && !paused){
      await hands.send({ image: video });
      // Timer
      let cur = totalElapsed + (performance.now()-startTime);
      timerEl.textContent = fmt(cur);
      totTimeEl.textContent = fmt(cur);
    }
    video.requestVideoFrameCallback(tick);
  }

  function fmt(ms){
    const s = Math.floor(ms/1000); const m=Math.floor(s/60); const r=s%60;
    return m+':'+String(r).padStart(2,'0');
  }

  // --- UI
  startBtn.onclick = async ()=>{
    if (!stream) await startCam();
    if (!running){ running=true; paused=false; startTime=performance.now(); setState('Running','go'); if (curStep===-1) startStep(0, startTime); }
  };
  pauseBtn.onclick = ()=>{
    if (!running) return;
    paused = !paused;
    if (paused){ totalElapsed += performance.now()-startTime; setState('Paused','pause'); }
    else { startTime = performance.now(); setState('Running','go'); }
  };
  resetBtn.onclick = ()=>{
    running=false; paused=false; setState('Idle','stop');
    curStep=-1; stepTimes.fill(0); totalElapsed=0; idleMs=0; lastHandsTs=0;
    clearCoverage(covA); clearCoverage(covB);
    sA.clearRect(0,0,sliceA.width,sliceA.height);
    sB.clearRect(0,0,sliceB.width,sliceB.height);
    roi.A=null; roi.B=null; awaitingClicks=0;
    overallScoreEl.textContent='—'; overallBar.style.width='0%';
    scoreSpeedEl.textContent=scorePBEl.textContent=scoreJEl.textContent=scoreEvenEl.textContent=scoreMessEl.textContent=scoreAsmEl.textContent='—';
    pbPctEl.textContent=jPctEl.textContent=messPctEl.textContent='0%';
    pbCoverEl.textContent=jCoverEl.textContent='0%'; idlePctEl.textContent='0%';
    updateCharts(); hidePrompt(); stepNameEl.textContent='—';
  };
  nextBtn.onclick = ()=>advance();

  function advance(){
    if (!running) return;
    const now = performance.now();
    if (curStep>=0) endStep(curStep, now);
    if (curStep < steps.length-1){
      startStep(curStep+1, now);
      // Special prompts
      if (curStep===1) showPrompt('Lay bread flat. Tap Next when centered.');
      if (curStep===2) showPrompt('Spread PB on Slice A until coverage ≥80%. Then Next.');
      if (curStep===3) showPrompt('Spread Jelly on Slice B until coverage ≥80%. Then Next.');
      if (curStep===4) showPrompt('Assemble slices smoothly. Tap Next.');
      if (curStep===5) showPrompt('Rotate sandwich slowly 360°. Keep it centered. Tap Next when done.');
      if (curStep===6) showPrompt('Cleanup. Close jars, wipe surface, wash hands.');
    } else {
      // finish
      totalElapsed += now - startTime;
      running=false; setState('Finished','stop'); hidePrompt();
    }
  }

  // Auto-resize canvas on rotation/resize
  window.addEventListener('resize', ()=>{
    // canvas is sized each frame from video
  });

  // Kick off
  try{
    const perm = await navigator.permissions.query({name:'camera'});
    // No auto-start for privacy.
  }catch(e){}

})();
</script>
</body>
</html>
